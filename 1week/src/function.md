------------------------------------------
```java
int max(int a, int b) {
    return if(a>b) a else b
}
```

```kotlin
fun max(a:Int, b:Int):Int {
    return if(a>b) a else b
}
```

자바와 다르게 코틀린은 fun 키워드를 통해 함수를 선언한다.

fun 다음에는 함수 이름이 온다. (return 타입은 파라미터의 뒤에 오게 된다.)

```kotlin
fun max(a:Int, b:Int):Int = if(a>b) a else b
```

자바와는 다르게 식이 본문인 함수도 만들 수 있다.

```kotlin
fun max(a:Int, b:Int) = if(a>b) a else b
```

식이 본문인 함수의 경우는 반환 타입을 적지 않아도 컴파일러가 분석하여 반환 타입을 정한다.

```java
int max(int a, int b) {
    return if(a>b) a else b
}

max(1, 2)
```

```kotlin
fun max(a:Int, b:Int):Int {
    return if(a>b) a else b
}

max(b=2, a=1) == max(1, 2)
```

코틀린은 파라미터 이름을 명시하여 전달할 수 있다.

```kotlin
fun max(a:Int, b:Int = 2):Int {
    return if(a>b) a else b
}

max(1)
```

코틀린은 디폴트 파라미터 값을 지정할 수 있다.

----------------

코틀린의 소스파일에 타겟 패키지에 넣을 함수를 선언하면

자바 컴파일러는 이를 코틀린의 소스 파일 이름을 클래스로 생성하고

해당 소스 파일의 함수를 클래스의 정적인 메소드로 만들어 준다.

즉 코틀린 파일의 모든 최상위 함수는 해당 클래스의 정적 메소드가 된다.

---------------------

함수와 마찬가지로 프로퍼티도 파일의 최상위 수준에 놓을 수 있다.

이런 프로퍼티의 값은 정적 필드에 저장된다.

이를 활용해서 코드에 상수를 추가할 수 있다.

하지만 접근자 메소드를 통해 노출되므로 겉으로만 상수처럼 보인다.

그렇기 때문에 상수로 만들고 싶으면 const 변경자를 사용하면 된다.

------------------------

```kotlin
fun String.lastChar():Char = this.get(this.length-1)
```

코틀린은 확장이라는 개념을 통해 메소드를 다른 클래스에 추가할 수 있다.

확장 함수는 어떤 클래스의 멤버 메소드처럼 호출할 수 있지만

그 클래스의 밖에서 선언된 함수이다.

확장 함수를 만드려면 추가하려는 함수 이름 앞에 함수가 확장할 클래스 이름을 붙이면 된다.

그러한 클래스 이름을 수신 객체 타입이라 부르며
(위의 예시에서는 String)

확장 함수가 호출되는 대상이 되는 값을 수신 객체라고 부른다.
(위의 예시에서는 this / 생략 가능하다)

호출 구문은 다른 일반 클래스 멤버를 호출하는 구문과 똑같다.
(위의 예시라면 "Kotlin".lastChar())

즉 기존의 클래스에 새로운 메소드를 추가하는 것과 같다.

확장 함수는 캡슐화를 깰 수 없다.

클래스 안에서 정의한 메소드와는 다르게 클래스 내부에서만 사용할 수 있는

private, protected 멤버를 사용할 수 없다.

확장 함수를 사용하기 위해서는 그 함수를 임포트해야 한다.

임포트 시에 as 키워드를 사용하면 클래스나 함수를 다른 이름으로도 부를 수 있다.

(import strings.lastChar as last로 임포트하면 "Kotlin".last()로 사용 가능)

확장 함수는 오버라이드 할 수 없다. (정적으로 결정하기 때문)

---------

(예제는 발표시에 추가하도록 할게요! 처음이라 가벼운 주제로 시작했습니다!)

